{"version":3,"sources":["../node_modules/giftbag/index.js","js/script.js"],"names":["console","log","Parallax","parallax","parallaxElements","document","querySelectorAll","setup","selector","init","scroll","Scroll","scrollElements"],"mappings":"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","file":"script.313e1c29.js","sourceRoot":"../src","sourcesContent":["// Scroll\nclass Scroll {\n\tconstructor() {\n\t\tthis.scrollElements = \"\";\n\t}\n\n\t// Set a custom selector\n\tsetup(options) {\n\t\tif (options) {\n\t\t\tif (options.selector) {\n\t\t\t\tthis.scrollElements = options.selector;\n\t\t\t}\n\t\t}\n\t}\n\n\t// run the scroll function\n\tinit() {\n\t\tconst observer = new IntersectionObserver(\n\t\t\tentries => {\n\t\t\t\tentries.forEach(entry => {\n\t\t\t\t\tconst attrArr = Object.values(entry.target.attributes);\n\n\t\t\t\t\t// default\n\t\t\t\t\tlet threshold = 0.1;\n\t\t\t\t\tlet playInReverse = false;\n\n\t\t\t\t\t// enable reverse and reassign threshold if specified in data-attr\n\t\t\t\t\tattrArr.map(attr => {\n\t\t\t\t\t\tif (attr.name === \"data-reverse\") {\n\t\t\t\t\t\t\tplayInReverse = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (attr.name === \"data-threshold\") {\n\t\t\t\t\t\t\tthreshold = parseFloat(attr.nodeValue);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthreshold = 0.1;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tif (entry.intersectionRatio >= threshold) {\n\t\t\t\t\t\tentry.target.classList.add(\"visible\");\n\t\t\t\t\t} else if (playInReverse) {\n\t\t\t\t\t\tentry.target.classList.remove(\"visible\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t{\n\t\t\t\tthreshold: [0, 0.2, 1]\n\t\t\t}\n\t\t);\n\n\t\tthis.scrollElements.forEach(el => {\n\t\t\tobserver.observe(el);\n\t\t});\n\t}\n}\n\n//  PARALLAX\nclass Parallax {\n\tconstructor() {\n\t\tthis.revealPoint = 0;\n\t\tthis.selector = \"\";\n\t\tthis.ease = \"ease-out\";\n\t}\n\n\tsetup(options) {\n\t\tif (options) {\n\t\t\tif (options.selector) {\n\t\t\t\tthis.selector = options.selector;\n\t\t\t}\n\t\t\tif (options.revealPoint) {\n\t\t\t\tthis.revealPoint = options.revealPoint;\n\t\t\t}\n\t\t\tif (options.ease) {\n\t\t\t\tthis.ease = options.ease;\n\t\t\t}\n\n\t\t\tif (options.direction) {\n\t\t\t\tthis.direction = options.direction;\n\t\t\t}\n\t\t}\n\t}\n\n\trunParallax() {\n\t\tconst pageTop = window.pageYOffset;\n\t\tconst pageMid = pageTop + window.innerHeight / 2;\n\n\t\tthis.selector.forEach(el => {\n\t\t\tconst wHeight = window.innerHeight;\n\t\t\tconst revealTop = el.getBoundingClientRect().top;\n\n\t\t\tlet active;\n\n\t\t\tif (revealTop < wHeight - this.revealPoint) {\n\t\t\t\tactive = true;\n\t\t\t} else {\n\t\t\t\tactive = false;\n\t\t\t}\n\n\t\t\tif (revealTop < 0 + this.revealPoint) {\n\t\t\t\tactive = false;\n\t\t\t}\n\n\t\t\tif (active) {\n\t\t\t\t// Run this if it already has a data attribute set\n\t\t\t\tconst topSection = el.offsetTop;\n\t\t\t\tconst midSection = topSection + el.offsetHeight / 2;\n\n\t\t\t\tconst viewDistanceLeft = pageMid - midSection;\n\t\t\t\tconst parallaxSpeed = parseFloat(\n\t\t\t\t\tel.getAttribute(\"data-parallax-speed\")\n\t\t\t\t);\n\n\t\t\t\t// Sets the parallax direction\n\t\t\t\tlet direction = \"\";\n\n\t\t\t\tif (el.hasAttribute(\"data-parallax-direction\")) {\n\t\t\t\t\t// Direction to value of the attribute\n\t\t\t\t\tdirection = el.getAttribute(\"data-parallax-direction\");\n\t\t\t\t} else {\n\t\t\t\t\t// Set default direction to vertical\n\t\t\t\t\tdirection = \"vertical\";\n\t\t\t\t}\n\n\t\t\t\t// Handle transform based on direction\n\t\t\t\tif (direction.toLowerCase() === \"vertical\") {\n\t\t\t\t\tel.style.transform = `translate3d(0, ${(viewDistanceLeft *\n\t\t\t\t\t\tparallaxSpeed) /\n\t\t\t\t\t\t3}px, 0)`;\n\t\t\t\t} else if (direction.toLowerCase() === \"horizontal\") {\n\t\t\t\t\tel.style.transform = `translate3d( ${(viewDistanceLeft *\n\t\t\t\t\t\tparallaxSpeed) /\n\t\t\t\t\t\t3}px, 0, 0)`;\n\t\t\t\t}\n\n\t\t\t\tel.style.transition = `transform ${this.ease}`;\n\t\t\t}\n\t\t});\n\t}\n\n\tinit() {\n\t\tdocument.addEventListener(\"scroll\", () => {\n\t\t\tthis.runParallax();\n\t\t});\n\t}\n}\n\n// EVENT GROUP\nclass EventGroup {\n\tconstructor() {\n\t\tthis.selector = \"\";\n\t}\n\n\tsetup(options) {\n\t\t// Setup of the custom selector\n\t\tif (options.selector) {\n\t\t\tthis.selector = options.selector;\n\t\t}\n\t}\n\n\tinit() {\n\t\tthis.selector.forEach(event => {\n\t\t\tconst listener = event.getAttribute(\"data-event\");\n\t\t\tconst setElement = event.getAttribute(\"data-event-element\");\n\t\t\tconst setClass = event.getAttribute(\"data-event-add\");\n\n\t\t\tevent.addEventListener(listener, () => {\n\t\t\t\tconst elements = document.querySelectorAll(`${setElement}`);\n\n\t\t\t\telements.forEach(element => {\n\t\t\t\t\telement.classList.toggle(setClass);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n}\n\n// DarkMode\nclass DarkMode {\n\tconstructor() {\n\t\tthis.wrapper = \"\";\n\t\tthis.darkModeClass = \"dark-mode-active\";\n\t\tthis.active = false;\n\t\tthis.trigger = \"\";\n\t}\n\n\tsetup(options) {\n\t\tif (options) {\n\t\t\tif (options.wrapper) {\n\t\t\t\tthis.wrapper = options.wrapper;\n\t\t\t}\n\t\t\tif (options.trigger) {\n\t\t\t\tthis.trigger = options.trigger;\n\t\t\t}\n\t\t\tif (options.darkModeClass) {\n\t\t\t\tthis.darkModeClass = options.darkModeClass;\n\t\t\t}\n\t\t}\n\t}\n\n\trenderDarkMode() {\n\t\tconst allElements = this.wrapper.querySelectorAll(\"*\");\n\n\t\tif (this.active === true) {\n\t\t\tdocument.body.setAttribute(\"data-dark-mode\", true);\n\t\t\tallElements.forEach(el => {\n\t\t\t\tel.classList.add(this.darkModeClass);\n\t\t\t});\n\t\t\tthis.active = false;\n\t\t\tlocalStorage.setItem(\"dark-mode\", \"true\");\n\t\t} else if (this.active === false) {\n\t\t\tallElements.forEach(el => {\n\t\t\t\tdocument.body.removeAttribute(\"data-dark-mode\");\n\t\t\t\tel.classList.remove(this.darkModeClass);\n\n\t\t\t\tthis.active = true;\n\t\t\t\tlocalStorage.removeItem(\"dark-mode\");\n\t\t\t});\n\t\t}\n\t}\n\n\tinit() {\n\t\tlet localStatus = localStorage.getItem(\"dark-mode\");\n\n\t\tif (localStatus == \"true\") {\n\t\t\tthis.active = true;\n\t\t}\n\n\t\tthis.renderDarkMode();\n\n\t\tthis.trigger.addEventListener(\"click\", () => {\n\t\t\tthis.renderDarkMode();\n\t\t});\n\t}\n}\n\n// Container Queries\nclass ContainerQueries {\n\tconstructor() {\n\t\tselector = \"\";\n\t\tattribute = \"\";\n\t}\n\n\tsetup(options) {\n\t\tif (options.selector) {\n\t\t\tthis.selector = options.selector;\n\t\t}\n\t\tif (options.attribute) {\n\t\t\tthis.attribue = options.attribute;\n\t\t}\n\t}\n\n\trunContainerQueries() {\n\t\tthis.selector.forEach(el => {\n\t\t\t// Get the value of the breakpoints attribute and split them into key value pairs\n\t\t\t// Reason why the breakpoints need a ; between each different size\n\t\t\tconst breakpointAttributes = el.getAttribute(this.attribue).split(\"; \");\n\n\t\t\t// Add the data-current-breakpoint attribute to the el and set it to initial\n\t\t\tel.setAttribute(\"data-current-breakpoint\", \"initial\");\n\n\t\t\t// Get the total width of the element\n\t\t\tconst elementWidth = el.clientWidth;\n\n\t\t\t// Create keys array\n\t\t\tlet keysArr = [];\n\t\t\t// Map through the breakpoint attributes and add a breakpoint class according to the key and the width according to the value\n\t\t\tbreakpointAttributes.map((attr, i) => {\n\t\t\t\t// Split them into key and value\n\t\t\t\tconst splitAttr = attr.split(\":\");\n\t\t\t\tconst key = splitAttr[0];\n\t\t\t\tconst value = +splitAttr[1];\n\n\t\t\t\t// If the value is greater or equal to the element width then you will add the current data-current-breakpoint\n\t\t\t\tif (value < elementWidth) {\n\t\t\t\t\tkeysArr.push(key);\n\t\t\t\t\t// Set the current index to be the current breakpoint\n\t\t\t\t\tel.dataset.currentBreakpoint = keysArr[i];\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tinit() {\n\t\tthis.runContainerQueries();\n\t}\n}\n\nmodule.exports = {\n\tScroll,\n\tParallax,\n\tEventGroup,\n\tDarkMode,\n\tContainerQueries\n};\n","import {Parallax, Scroll} from 'giftbag'\n\nconsole.log(Parallax)\n\n// All Giftbag follow a pattern\n// 1. Create\n// 2. Setup\n// 3. Initialize\n\n// 1. Create new parallax\nconst parallax = new Parallax();\n\n// 2. Setup parallax\nconst parallaxElements = document.querySelectorAll('.parallax-element');\nparallax.setup({\n    selector: parallaxElements //these elements will be selected\n});\n\n// 3. Init\nparallax.init();\n\n\n// Scroll based animations\nconst scroll = new Scroll();\nconst scrollElements = document.querySelectorAll('.scroll-element');\nscroll.setup({\n    selector: scrollElements\n});\nscroll.init()"]}